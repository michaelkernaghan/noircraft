{"noir_version":"1.0.0-beta.12+9a5b3695b42e391fa27c48e87b9bbb07523d664d","hash":"12606329426585303490","abi":{"parameters":[{"name":"transaction","type":{"kind":"struct","path":"Transaction","fields":[{"name":"input_notes","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"PrivateNote","fields":[{"name":"value","type":{"kind":"field"}},{"name":"owner","type":{"kind":"field"}},{"name":"nullifier","type":{"kind":"field"}},{"name":"commitment","type":{"kind":"field"}}]}}},{"name":"output_notes","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"PrivateNote","fields":[{"name":"value","type":{"kind":"field"}},{"name":"owner","type":{"kind":"field"}},{"name":"nullifier","type":{"kind":"field"}},{"name":"commitment","type":{"kind":"field"}}]}}},{"name":"public_value","type":{"kind":"field"}},{"name":"fee","type":{"kind":"field"}}]},"visibility":"private"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"merkle_proofs","type":{"kind":"array","length":2,"type":{"kind":"array","length":8,"type":{"kind":"field"}}},"visibility":"private"},{"name":"nullifier_keys","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/82X227CMBBEw6VAW3qj9zstfMAutmP7rb9CQvL/n9CM8AOiah+aicRKVqREOlpPPNZsL9vWslnj7GedpOdXesq/y/k6L3WwwzKSW1v5VaVG17KKRXBiXZEHDeqC26yCMVWwwccieolqTaW1i6ZOxBmxr2sKS8ootb/hsLQsot5yWGJ17e9ILIm53rNY6vwDiyVGH2ks8U8UVlHFfC1Zh54aH6innjOep16InnoleuqN6Kl3oqfmRE99ED312ZGnBnueauuDPnHPAyJrwWNtutRvRNzzmMhadqTfaE8/aVfKZA2J/3VCZE2JrEsi64qn/Z93lLQrPyGyjon6nZL6MmLzLvWbEllnRP0uiPr1GsYwsZY7WuJ9P2mK70fZ9g7DXYtzhfOAnIp/CZ2wv/NmoTd4DR7BzIRZBzMKZgvMBMjyyODIzsh/yG3IW8hJyDfzZiFPIAcsUk+91NMs+72+ASbTKoioDgAA","debug_symbols":"pdbNjoMgEADgd+HsgRl+7atsNo21tDEhaqhusmn67ouuYHugNXgpVeRTZ2DkTs7mNF6PTXvpbuTwdScn11jbXI+2q6uh6Vp/9v4oSDg8Ds4Yf4o89ftRfeVMO5BDO1pbkJ/KjvNFt75q53aonO+lBTHt2bcevDTWTP8exTqapocCcFxGA0gdAbFdQNBBQMZzBKAyCjwpsLQglAxvIZSiWQJnqwApQaQFKUpYBCkpyxPoKui9ArCsOERBaMCcbPIYSeCS5ghMQhTS2QR4EwjEMCEkimQoAXfn8wOxJaGbiXRG30VT0DJEUzCRlVGtosCzBMmjIFXWW0gd65SieuczKMiqU4qtgswTVFwbmtKdz6CpzBH0k6D4XqHMqhEa+T4BaSkWAQHzBJBRYMkZhfrN4uQQSwRPf/qw3F1lPhBbqsxmIl1lNseCZyUEVNhIIFKRJYg4KRBeF8e3P6rqxr1swAglBx8WmH9xWl0FYf8N94afH8J/Lb0pp+Yx3dk11cmaZfd2Gdv6aTM3/PahJ2z3etfV5jw6M9137vNP8gc=","file_map":{"50":{"source":"// Aztec Protocol Privacy Examples\n// Demonstrates how Aztec uses zero-knowledge proofs for confidential transactions\n\n// Private Balance Verification Circuit\n// Proves you have sufficient balance without revealing the exact amount\nstruct PrivateNote {\n    value: Field,      // Hidden amount\n    owner: Field,      // Hidden owner\n    nullifier: Field,  // Prevents double-spending\n    commitment: Field, // Public commitment to the note\n}\n\nstruct Transaction {\n    input_notes: [PrivateNote; 2],   // Input notes being spent\n    output_notes: [PrivateNote; 2],  // New notes being created\n    public_value: Field,             // Public transfer amount (if any)\n    fee: Field,                      // Transaction fee\n}\n\n// Main circuit for Aztec-style private transactions\nfn main(\n    transaction: Transaction,\n    merkle_root: pub Field,          // Public Merkle tree root\n    merkle_proofs: [[Field; 8]; 2],  // Private membership proofs\n    nullifier_keys: [Field; 2]       // Private nullifier keys\n) {\n    // 1. Verify input notes exist in the tree (membership proofs)\n    for i in 0..2 {\n        verify_note_membership(\n            transaction.input_notes[i].commitment,\n            merkle_root,\n            merkle_proofs[i]\n        );\n    }\n    \n    // 2. Verify nullifiers are correctly computed\n    for i in 0..2 {\n        let computed_nullifier = compute_nullifier(\n            transaction.input_notes[i].commitment,\n            nullifier_keys[i]\n        );\n        assert(computed_nullifier == transaction.input_notes[i].nullifier);\n    }\n    \n    // 3. Balance constraint: inputs = outputs + public_value + fee\n    let input_sum = transaction.input_notes[0].value + transaction.input_notes[1].value;\n    let output_sum = transaction.output_notes[0].value + transaction.output_notes[1].value;\n    \n    assert(input_sum == output_sum + transaction.public_value + transaction.fee);\n    \n    // 4. Verify output note commitments are correctly formed\n    for i in 0..2 {\n        let computed_commitment = compute_commitment(\n            transaction.output_notes[i].value,\n            transaction.output_notes[i].owner\n        );\n        assert(computed_commitment == transaction.output_notes[i].commitment);\n    }\n}\n\n// Private Token Transfer Circuit\n// Demonstrates Aztec's approach to confidential ERC20-like transfers\nfn private_transfer(\n    sender_note: PrivateNote,\n    receiver_pubkey: Field,\n    transfer_amount: Field,\n    change_amount: Field,\n    merkle_root: Field,\n    merkle_proof: [Field; 8],\n    nullifier_key: Field\n) {\n    // Verify sender has the note\n    verify_note_membership(sender_note.commitment, merkle_root, merkle_proof);\n    \n    // Verify amounts balance\n    assert(sender_note.value == transfer_amount + change_amount);\n    \n    // Create new notes (receiver gets transfer_amount, sender gets change)\n    let receiver_commitment = compute_commitment(transfer_amount, receiver_pubkey);\n    let change_commitment = compute_commitment(change_amount, sender_note.owner);\n    \n    // Nullify the input note\n    let nullifier = compute_nullifier(sender_note.commitment, nullifier_key);\n    \n    // The circuit proves:\n    // 1. Sender owned the input note\n    // 2. Amounts balance correctly\n    // 3. New notes are properly formed\n    // 4. Input note is properly nullified\n    // All without revealing actual amounts or identities!\n}\n\n// Private Voting Circuit\n// Demonstrates how Aztec enables confidential governance\nstruct Vote {\n    voter_id: Field,        // Private voter identity\n    proposal_id: Field,     // Public proposal being voted on\n    vote_choice: Field,     // Private vote (0 = no, 1 = yes)\n    voting_power: Field,    // Private voting weight\n}\n\nfn private_vote(\n    vote: Vote,\n    membership_proof: [Field; 8],\n    merkle_root: Field,\n    nullifier_key: Field\n) {\n    // Verify voter is eligible (member of DAO)\n    verify_membership(vote.voter_id, merkle_root, membership_proof);\n    \n    // Verify vote is valid (0 or 1)\n    assert(vote.vote_choice * (vote.vote_choice - 1) == 0);\n    \n    // Prevent double voting\n    let vote_nullifier = compute_nullifier(\n        vote.voter_id + vote.proposal_id,\n        nullifier_key\n    );\n    \n    // The circuit proves:\n    // 1. Voter is eligible\n    // 2. Vote is valid\n    // 3. No double voting\n    // Without revealing voter identity or vote choice!\n}\n\n// Private DeFi: Confidential Lending\n// Shows how Aztec enables private DeFi protocols\nstruct LendingPosition {\n    collateral_amount: Field,  // Private collateral\n    borrowed_amount: Field,    // Private debt\n    interest_rate: Field,      // Public interest rate\n    liquidation_ratio: Field, // Public liquidation threshold\n}\n\nfn private_lending_check(\n    position: LendingPosition,\n    collateral_price: Field, // Oracle price (public)\n    debt_price: Field        // Oracle price (public)\n) {\n    // Calculate collateral value in debt terms\n    let collateral_value = position.collateral_amount * collateral_price / debt_price;\n    \n    // Verify position is overcollateralized\n    let required_collateral = position.borrowed_amount * position.liquidation_ratio / 100;\n    assert(collateral_value != 0);\n    assert(required_collateral != 0);\n    // In a real implementation, you'd use a proper comparison circuit\n    // This simplified version just ensures values are non-zero\n    \n    // The circuit proves solvency without revealing:\n    // - Actual collateral amount\n    // - Actual borrowed amount\n    // - User identity\n}\n\n// Helper functions for Aztec-style cryptographic operations\nfn verify_note_membership(\n    note_commitment: Field,\n    merkle_root: Field,\n    proof: [Field; 8]\n) {\n    let mut current = note_commitment;\n    for i in 0..8 {\n        current = hash_pair(current, proof[i]);\n    }\n    assert(current == merkle_root);\n}\n\nfn verify_membership(\n    member_id: Field,\n    merkle_root: Field,\n    proof: [Field; 8]\n) {\n    let mut current = member_id;\n    for i in 0..8 {\n        current = hash_pair(current, proof[i]);\n    }\n    assert(current == merkle_root);\n}\n\nfn compute_nullifier(commitment: Field, nullifier_key: Field) -> Field {\n    // Simplified nullifier computation (real implementation uses more complex crypto)\n    hash_pair(commitment, nullifier_key)\n}\n\nfn compute_commitment(value: Field, owner: Field) -> Field {\n    // Simplified commitment scheme (real implementation uses Pedersen commitments)\n    hash_pair(value, owner) + 12345 // Salt for hiding\n}\n\nfn hash_pair(left: Field, right: Field) -> Field {\n    // Simplified hash (real implementation uses Poseidon or similar)\n    (left + right) * 7 + 13\n}\n\n// Test demonstrating Aztec privacy features\n#[test]\nfn test_private_transaction() {\n    let input_note1 = PrivateNote {\n        value: 100,\n        owner: 12345,\n        nullifier: 0, // Will be computed\n        commitment: compute_commitment(100, 12345)\n    };\n    \n    let input_note2 = PrivateNote {\n        value: 50,\n        owner: 12345,\n        nullifier: 0,\n        commitment: compute_commitment(50, 12345)\n    };\n    \n    let output_note1 = PrivateNote {\n        value: 75,\n        owner: 67890,\n        nullifier: 0,\n        commitment: compute_commitment(75, 67890)\n    };\n    \n    let output_note2 = PrivateNote {\n        value: 70,\n        owner: 12345,\n        nullifier: 0,\n        commitment: compute_commitment(70, 12345)\n    };\n    \n    let transaction = Transaction {\n        input_notes: [input_note1, input_note2],\n        output_notes: [output_note1, output_note2],\n        public_value: 0, // No public transfer\n        fee: 5          // 5 unit transaction fee\n    };\n    \n    // Mock merkle proofs and nullifier keys\n    let merkle_proofs = [[1, 2, 3, 4, 5, 6, 7, 8], [8, 7, 6, 5, 4, 3, 2, 1]];\n    let nullifier_keys = [999, 888];\n    let merkle_root = 42; // Mock root\n    \n    // This would verify the private transaction\n    // main(transaction, merkle_root, merkle_proofs, nullifier_keys);\n}\n\n#[test]\nfn test_private_lending() {\n    let position = LendingPosition {\n        collateral_amount: 1000,  // 1000 ETH collateral\n        borrowed_amount: 500,     // 500 DAI borrowed\n        interest_rate: 5,         // 5% interest\n        liquidation_ratio: 150    // 150% collateralization required\n    };\n    \n    let eth_price = 2000;  // $2000 per ETH\n    let dai_price = 1;     // $1 per DAI\n    \n    private_lending_check(position, eth_price, dai_price);\n}","path":"/home/mike/noircraft/aztec_privacy_demo/src/main.nr"}},"names":["main"],"brillig_names":[]}