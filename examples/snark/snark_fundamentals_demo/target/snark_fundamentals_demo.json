{"noir_version":"1.0.0-beta.12+9a5b3695b42e391fa27c48e87b9bbb07523d664d","hash":"8194364804534763402","abi":{"parameters":[{"name":"hash_challenge","type":{"kind":"field"},"visibility":"public"},{"name":"min_age","type":{"kind":"field"},"visibility":"public"},{"name":"max_age","type":{"kind":"field"},"visibility":"public"},{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"public_key","type":{"kind":"field"},"visibility":"public"},{"name":"message_hash","type":{"kind":"field"},"visibility":"public"},{"name":"expected_sum","type":{"kind":"field"},"visibility":"public"},{"name":"hash_preimage","type":{"kind":"field"},"visibility":"private"},{"name":"age","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_proof","type":{"kind":"struct","path":"MerkleProof","fields":[{"name":"leaf","type":{"kind":"field"}},{"name":"path","type":{"kind":"array","length":3,"type":{"kind":"field"}}},{"name":"indices","type":{"kind":"array","length":3,"type":{"kind":"boolean"}}}]},"visibility":"private"},{"name":"signature","type":{"kind":"struct","path":"SimpleSignature","fields":[{"name":"r","type":{"kind":"field"}},{"name":"s","type":{"kind":"field"}}]},"visibility":"private"},{"name":"private_values","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1ai1LaUBBdHhbB+mhFRa2oVVHro/cSAklnWm2n43+oxc/st5WVe8fLJcJgztJguzPMYoIn+zy7JOSoLze910/zPtd7FYxeNNo9tpRwbNlocvS10Sqd6FIPo5SAG6h2q9XtNLs60LeqGd9FoWqFd+1IRzqMwl/NKAi6USvqxHdxR8W6FXT1QxgHDwYYZWOggrhocPI0LOh4zOOwVIK5L8XW/gE3FhtG18grHD7x2ztWc4ywUkhn3JCx8y8vJOUVkt4gXFHWSCa5eS9+ae1E+rw5wudJsd062jS1VaQnwvIFTSobYF+sbEkavJVQIGmN3yJcs24TlvUlYrhN45l+0utsE5YM0JOoZvweVzvjJLjXXXXbvlcPfUHm+wMwhi65MO4V9cmFaDqTP0ezN/l3jK7bgNgA8gl/8tdJfvK7QUw7+XcIV6h1mo3Jj/R5l2Qm/y5Nf/LvkMzk35M0eI/wk3+PcM26T9me/BzDfcJP/n3K9uSvG7/Rkx+Z74/AGLrkwrjjJn/auHiia5SJQTM06RNcF9kiDow+JBrcGA5peGMopjNkyDCp4KfdPg6Adh0KFQWacA+AeZ3m6p4nLKH78kLskU13ZHTDBsQ2HZ/wV/cGya/uecI1zxHhirJBMslFr+5In49JZnU/pumv7kdgX6ycSBp8QvjV/YRwzXoK9FcqhqeEX91PCUsG6EnUMH6jV3dkvj8BY+iSC+NOurpn6ImOTjFo/trqfmb0OdHgxnBO41f3rAY/7fZxBvTxXKgo0IR7BsxFkn0qnegK9X/vgN5ay0CsRWA+Lkh2UKW1z+YDjRsL+63SyWOOLwT8/pLxfJeF8n0D9tvKPDjvSJ6oALEWgLlA8tcl0EcgJ2hgn2lg7Tbd2kUvuUtArM+E3ROslGakX7PUY+p/j02ExRjofYB765Lwc/ErZXsPYh5QAn5/I5l9AP3YCTl3NdAuYN1oYC4GuL4Arpnm64+fSA8zdzUFevgq434zd2kBv69pNrjrLdDnAGgXsG40MBcD3IXezZeBWC2aDb4OX3/NiPAW10pAeN76nnG/ua5DAb9/0L/H122gXcC60cBciHJX5/XH77GW0z6A9u1j7kLGjjmBaxnNCQXKNhfO9TDeEX4PKQJtXCEZXn0D9vkN0Of3QKxVIFYViLUGxFoH1gj3mJ25K0bz/WR+BsT3gfn+Ld+v4TnK91/5e++y+Sz3EueOY86xYh/X6el+NEvO9FvBXGfOqUVXbE/aZ09loysODpBfmhZ/QQZflRJ8rDjvF57xv5jwf7ln/s57etRnR/3acDHhnMVcNdq11/pR9vSagwuMpbb4VRn8xFytOe+rnp9uvK9BNlg8u3PN0bDkvXP2s37P5PD2ad+WQsK1rNiaqTrHbDz/ANo7zWKYQwAA","debug_symbols":"tZbNjqMwDIDfJWcOsZ3fvspqVdGWjpAQrZiy0qrqu68hDjM9BK1Ac8nXEvzJcUzgqS7Nafw4tv319qkOv57qNLRd134cu9u5frS3nq8+X5XKf4+PoWn4kvo2z1H3emj6hzr0Y9dV6k/djfNNn/e6n/moB57VlWr6C5OF17Zrpl+v6ital0MpuBxNEb4E9t0AZUMAFEEgKsVjOd4SSby1uC/ebcrfuJy/N6X4tQrGaERgNNmSwZUNADGXEFDHLQYEWgzo9+awzUA6dxIQmE2r8PE/DCt7YXSweS+gvBew0k4QQ+4HiDFuUaBeHgnUGDYpQC8KoGIpwK4sxPulJ3yw+xXbaoGYFYi2nEXYv5DwwwsJuTmRwG1pTgghNycaKB51a0kEl5uT08FtCot7FVHnpwwj+S2lIL2cmWTLpVg5LAhtriah8xsVuFuxnBZE+r03f/O/+twOb698RTxZKaMOvlJ2Ht08+nkM8xjnEXQCJGACJSQBsIGrAC7BJ4SEOAN1AiRgAiWYhGRBtnCLo08ICXEGsQV4QwmEKCShEVqhE3phEMZEIz4z+fjlbFBIQiO00xnKnHy8YOOFQRgTrRaCEFOcJaERis+Kz4rPis+Kz4nPQbrfic+Jz4nPTT7O07EPeV+dn56J19QwQ1ufukY+865jf/721ff4e88z+bvwPtzOzWUcmqld5jluoH8=","file_map":{"50":{"source":"// SNARK Fundamentals Demo\n// Exploring the core concepts: arithmetic circuits, statements, witnesses\n// Based on the lecture content about SNARKs and zero-knowledge proofs\n\n// Example 1: Hash Preimage Circuit\n// Statement: \"I know a message m such that SHA-256(m) = h\"\n// Public input (statement): h (the hash)\n// Private input (witness): m (the preimage)\n\n// Simple hash function for demonstration (not cryptographically secure)\nfn simple_hash(preimage: Field) -> Field {\n    // Simplified hash: just square and add a constant\n    preimage * preimage + 12345\n}\n\n// Circuit 1: Hash Preimage Knowledge\n// This proves \"I know a preimage m such that hash(m) = public_hash\"\nfn prove_hash_preimage(\n    public_hash: Field,  // Public statement\n    preimage: Field      // Private witness\n) {\n    let computed_hash = simple_hash(preimage);\n    assert(computed_hash == public_hash);\n}\n\n// Example 2: Range Proof Circuit\n// Statement: \"I know a value x such that 18 <= x <= 65\"\n// Public inputs: min_age, max_age\n// Private input: actual_age\nfn prove_age_in_range(\n    min_age: Field,\n    max_age: Field,\n    actual_age: Field  // Private witness\n) {\n    // Prove age is at least min_age\n    assert(actual_age as u64 >= min_age as u64);\n    // Prove age is at most max_age  \n    assert(actual_age as u64 <= max_age as u64);\n}\n\n// Example 3: Merkle Tree Membership\n// Statement: \"I know a leaf and path that proves membership in a Merkle tree\"\n// Public input: merkle_root\n// Private inputs: leaf, path\nstruct MerkleProof {\n    leaf: Field,\n    path: [Field; 3],      // Sibling hashes for 3-level tree\n    indices: [bool; 3],    // Direction indicators (left=false, right=true)\n}\n\nfn hash_pair(left: Field, right: Field) -> Field {\n    // Simple hash function for Merkle tree\n    left + right + 1\n}\n\nfn prove_merkle_membership(\n    merkle_root: Field,\n    proof: MerkleProof\n) {\n    let mut current_hash = proof.leaf;\n    \n    // Traverse up the tree\n    for i in 0..3 {\n        let sibling = proof.path[i];\n        if proof.indices[i] {\n            // Current node is on the right\n            current_hash = hash_pair(sibling, current_hash);\n        } else {\n            // Current node is on the left\n            current_hash = hash_pair(current_hash, sibling);\n        }\n    }\n    \n    assert(current_hash == merkle_root);\n}\n\n// Example 4: Digital Signature Verification\n// Statement: \"I know a signature that verifies against a public key and message\"\n// Public inputs: public_key, message_hash\n// Private input: signature\nstruct SimpleSignature {\n    r: Field,\n    s: Field,\n}\n\nfn verify_signature(\n    public_key: Field,\n    message_hash: Field,\n    signature: SimpleSignature  // Private witness\n) {\n    // Simplified signature verification (not real ECDSA)\n    // In practice, this would involve elliptic curve operations\n    let verification_value = signature.r + signature.s * message_hash;\n    assert(verification_value == public_key);\n}\n\n// Example 5: Private Sum Circuit\n// Statement: \"I know values that sum to a public total\"\n// Public input: expected_sum\n// Private inputs: individual values\nfn prove_private_sum(\n    expected_sum: Field,\n    values: [Field; 5]  // Private witnesses\n) {\n    let mut sum = 0;\n    for i in 0..5 {\n        sum = sum + values[i];\n    }\n    assert(sum == expected_sum);\n}\n\n// Main circuit demonstrating multiple SNARK concepts\nfn main(\n    // Public statements (what the verifier knows)\n    hash_challenge: pub Field,\n    min_age: pub Field,\n    max_age: pub Field,\n    merkle_root: pub Field,\n    public_key: pub Field,\n    message_hash: pub Field,\n    expected_sum: pub Field,\n    \n    // Private witnesses (what only the prover knows)\n    hash_preimage: Field,\n    age: Field,\n    merkle_proof: MerkleProof,\n    signature: SimpleSignature,\n    private_values: [Field; 5]\n) {\n    // Prove knowledge of hash preimage\n    prove_hash_preimage(hash_challenge, hash_preimage);\n    \n    // Prove age is in valid range (privacy-preserving age verification)\n    prove_age_in_range(min_age, max_age, age);\n    \n    // Prove membership in Merkle tree\n    prove_merkle_membership(merkle_root, merkle_proof);\n    \n    // Prove knowledge of valid signature\n    verify_signature(public_key, message_hash, signature);\n    \n    // Prove knowledge of values that sum correctly\n    prove_private_sum(expected_sum, private_values);\n}\n\n// Test cases demonstrating the concepts\n#[test]\nfn test_hash_preimage() {\n    let preimage = 42;\n    let hash = simple_hash(preimage);\n    prove_hash_preimage(hash, preimage);\n}\n\n#[test]\nfn test_age_range() {\n    prove_age_in_range(18, 65, 25);  // Valid age\n}\n\n#[test]\nfn test_merkle_proof() {\n    // Build a simple 3-level Merkle tree\n    let leaf = 100;\n    let sibling1 = 200;\n    let sibling2 = 300;\n    let sibling3 = 400;\n    \n    // Calculate intermediate hashes\n    let level1 = hash_pair(leaf, sibling1);\n    let level2 = hash_pair(level1, sibling2);\n    let root = hash_pair(level2, sibling3);\n    \n    let proof = MerkleProof {\n        leaf,\n        path: [sibling1, sibling2, sibling3],\n        indices: [false, false, false]  // All left positions\n    };\n    \n    prove_merkle_membership(root, proof);\n}\n\n#[test]\nfn test_signature_verification() {\n    let pub_key = 1000;\n    let msg_hash = 500;\n    // This would fail with invalid signature\n    // let sig = SimpleSignature { r: 200, s: 1 };  // 200 + 1*500 = 700 != 1000\n    // verify_signature(pub_key, msg_hash, sig);\n    \n    // Create valid signature\n    let valid_sig = SimpleSignature { r: 500, s: 1 };  // 500 + 1*500 = 1000\n    verify_signature(pub_key, msg_hash, valid_sig);\n}\n\n#[test]\nfn test_private_sum() {\n    let values = [10, 20, 30, 40, 50];  // Sum = 150\n    prove_private_sum(150, values);\n}\n","path":"/home/mike/noircraft/snark_fundamentals_demo/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}